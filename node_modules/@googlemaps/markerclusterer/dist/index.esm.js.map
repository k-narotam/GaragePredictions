{"version":3,"file":"index.esm.js","sources":["../src/cluster.ts","../src/algorithms/utils.ts","../src/algorithms/core.ts","../src/algorithms/grid.ts","../src/algorithms/noop.ts","../src/algorithms/kmeans.ts","../src/algorithms/dbscan.ts","../src/algorithms/supercluster.ts","../src/renderer.ts","../src/overlay-view-safe.ts","../src/markerclusterer.ts"],"sourcesContent":["/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the markers and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface AlgorithmOutput {\n  /**\n   * The clusters returned based upon the {@link AlgorithmInput}.\n   */\n  clusters: Cluster[];\n  /**\n   * A boolean flag indicating that the clusters have not changed.\n   */\n  changed?: boolean;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => AlgorithmOutput;\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does preprocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): AlgorithmOutput;\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers,\n          map,\n          mapCanvasProjection,\n        }),\n        changed: false,\n      };\n    }\n\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(\n          map,\n          mapCanvasProjection,\n          markers,\n          this.viewportPadding\n        ),\n        map,\n        mapCanvasProjection,\n      }),\n    };\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { distanceBetweenPoints, extendBoundsToPaddedViewport } from \"./utils\";\n\nimport { Cluster } from \"../cluster\";\n\nexport interface GridOptions extends ViewportAlgorithmOptions {\n  gridSize?: number;\n  /**\n   * Max distance between cluster center and point in meters.\n   * @default 10000\n   */\n  maxDistance?: number;\n}\n\n/**\n * The default Grid algorithm historically used in Google Maps marker\n * clustering.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n */\nexport class GridAlgorithm extends AbstractViewportAlgorithm {\n  protected gridSize: number;\n  protected maxDistance: number;\n  protected clusters: Cluster[] = [];\n\n  constructor({ maxDistance = 40000, gridSize = 40, ...options }: GridOptions) {\n    super(options);\n\n    this.maxDistance = maxDistance;\n    this.gridSize = gridSize;\n  }\n\n  protected cluster({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    this.clusters = [];\n    markers.forEach((marker) => {\n      this.addToClosestCluster(marker, map, mapCanvasProjection);\n    });\n\n    return this.clusters;\n  }\n\n  protected addToClosestCluster(\n    marker: google.maps.Marker,\n    map: google.maps.Map,\n    projection: google.maps.MapCanvasProjection\n  ): void {\n    let maxDistance = this.maxDistance; // Some large number\n    let cluster: Cluster = null;\n\n    for (let i = 0; i < this.clusters.length; i++) {\n      const candidate = this.clusters[i];\n      const distance = distanceBetweenPoints(\n        candidate.bounds.getCenter().toJSON(),\n        marker.getPosition().toJSON()\n      );\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        cluster = candidate;\n      }\n    }\n\n    if (\n      cluster &&\n      extendBoundsToPaddedViewport(\n        cluster.bounds,\n        projection,\n        this.gridSize\n      ).contains(marker.getPosition())\n    ) {\n      cluster.push(marker);\n    } else {\n      const cluster = new Cluster({ markers: [marker] });\n      this.clusters.push(cluster);\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractAlgorithm,\n  AlgorithmInput,\n  AlgorithmOptions,\n  AlgorithmOutput,\n} from \"./core\";\n\nimport { Cluster } from \"../cluster\";\n\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nexport class NoopAlgorithm extends AbstractAlgorithm {\n  constructor({ ...options }: AlgorithmOptions) {\n    super(options);\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    return {\n      clusters: this.cluster({ markers, map, mapCanvasProjection }),\n      changed: false,\n    };\n  }\n\n  protected cluster(input: AlgorithmInput): Cluster[] {\n    return this.noop(input);\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersKmeans from \"@turf/clusters-kmeans\";\n\nexport interface KmeansAlgorithmOptions extends ViewportAlgorithmOptions {\n  numberOfClusters: number | ((count: number, zoom: number) => number);\n}\n\n/**\n * Experimental algorithm using Kmeans.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-kmeans\n */\nexport class KmeansAlgorithm extends AbstractViewportAlgorithm {\n  protected numberOfClusters:\n    | number\n    | ((count: number, zoom: number) => number);\n\n  constructor({ numberOfClusters, ...options }: KmeansAlgorithmOptions) {\n    super(options);\n    this.numberOfClusters = numberOfClusters;\n  }\n\n  protected cluster({ markers, map }: AlgorithmInput): Cluster[] {\n    const clusters: Cluster[] = [];\n\n    if (markers.length === 0) {\n      return clusters;\n    }\n    const points = featureCollection(\n      markers.map((marker) => {\n        return point([marker.getPosition().lng(), marker.getPosition().lat()]);\n      })\n    );\n\n    let numberOfClusters: number;\n\n    if (this.numberOfClusters instanceof Function) {\n      numberOfClusters = this.numberOfClusters(markers.length, map.getZoom());\n    } else {\n      numberOfClusters = this.numberOfClusters;\n    }\n    clustersKmeans(points, { numberOfClusters }).features.forEach(\n      (point, i) => {\n        if (!clusters[point.properties.cluster]) {\n          clusters[point.properties.cluster] = new Cluster({\n            position: {\n              lng: point.properties.centroid[0],\n              lat: point.properties.centroid[1],\n            },\n            markers: [],\n          });\n        }\n\n        clusters[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return clusters;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { Units, featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersDbscan from \"@turf/clusters-dbscan\";\n\nexport interface DBScanOptions {\n  units?: Units;\n  minPoints?: number;\n  mutate?: boolean;\n}\n\nexport interface DBScanAlgorithmOptions extends ViewportAlgorithmOptions {\n  maxDistance?: number;\n  minPoints?: number;\n}\n\nconst DEFAULT_INTERNAL_DBSCAN_OPTION: DBScanOptions = {\n  units: \"kilometers\",\n  mutate: false,\n  minPoints: 1,\n};\n\n/**\n *\n * **This algorithm is not yet ready for use!**\n *\n * Experimental algorithm using DBScan.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-dbscan\n */\nexport class DBScanAlgorithm extends AbstractViewportAlgorithm {\n  protected maxDistance: number;\n  protected options: DBScanOptions;\n  constructor({\n    maxDistance = 200,\n    minPoints = DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints,\n    ...options\n  }: DBScanAlgorithmOptions) {\n    super(options);\n    this.maxDistance = maxDistance;\n    this.options = {\n      ...DEFAULT_INTERNAL_DBSCAN_OPTION,\n      minPoints,\n    };\n  }\n\n  protected cluster({\n    markers,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    const points = featureCollection(\n      markers.map((marker) => {\n        const projectedPoint = mapCanvasProjection.fromLatLngToContainerPixel(\n          marker.getPosition()\n        );\n        return point([projectedPoint.x, projectedPoint.y]);\n      })\n    );\n\n    const grouped: google.maps.Marker[][] = [];\n\n    clustersDbscan(points, this.maxDistance, this.options).features.forEach(\n      (point, i) => {\n        if (!grouped[point.properties.cluster]) {\n          grouped[point.properties.cluster] = [];\n        }\n\n        grouped[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return grouped.map((markers) => new Cluster({ markers }));\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOutput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal/es6\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  { [name: string]: any },\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  protected clusters: Cluster[];\n  protected state: { zoom: number };\n\n  constructor({ maxZoom, radius = 60, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius,\n      ...options,\n    });\n\n    this.state = { zoom: null };\n  }\n  public calculate(input: AlgorithmInput): AlgorithmOutput {\n    let changed = false;\n\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n\n    const state = { zoom: input.map.getZoom() };\n\n    if (!changed) {\n      if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) {\n        // still beyond maxZoom, no change\n      } else {\n        changed = changed || !equal(this.state, state);\n      }\n    }\n\n    this.state = state;\n\n    if (changed) {\n      this.clusters = this.cluster(input);\n    }\n\n    return { clusters: this.clusters, changed };\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    return this.superCluster\n      .getClusters([-180, -90, 180, 90], map.getZoom())\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link SuperClusterAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an array of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n * <iframe src=\"https://googlemaps.github.io/js-three/public/anchor/index.html\"></iframe>\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = [...markers];\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    if (this.markers.includes(marker)) {\n      return;\n    }\n\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = this.removeMarker(marker, true) || removed;\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.length = 0;\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const { clusters, changed } = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // allow algorithms to return flag on whether the clusters/markers have changed\n      if (changed || changed == undefined) {\n        // reset visibility of markers and clusters\n        this.reset();\n\n        // store new clusters\n        this.clusters = clusters;\n\n        this.renderClusters();\n      }\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;MAqBa,OAAO;IAKlB,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAkB;QAC/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,IAAI,QAAQ,EAAE;YACZ,IAAI,QAAQ,YAAY,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE;gBAC1C,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;aAC3B;iBAAM;gBACL,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aACnD;SACF;KACF;IAED,IAAW,MAAM;QACf,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YAChD,OAAO,SAAS,CAAC;SAClB;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,MAAM;YACxC,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC;SAC5C,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;KAClE;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;KAClD;;;;IAKD,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAqB,KAAK,CAAC,CAAC,UAAU,EAAE,CAAC;aAClE,MAAM,CAAC;KACX;;;;IAKM,IAAI,CAAC,MAA0B;QACpC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC3B;;;;IAKM,MAAM;QACX,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACzB,OAAO,IAAI,CAAC,MAAM,CAAC;SACpB;QACD,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;KACzB;;;AC5EH;;;;;;;;;;;;;;;MAgBa,6BAA6B,GAAG,CAC3C,GAAoB,EACpB,mBAAoD,EACpD,OAA6B,EAC7B,eAAuB;IAEvB,MAAM,iBAAiB,GAAG,4BAA4B,CACpD,GAAG,CAAC,SAAS,EAAE,EACf,mBAAmB,EACnB,eAAe,CAChB,CAAC;IACF,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,KAC3B,iBAAiB,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CACjD,CAAC;AACJ,EAAE;AAEF;;;MAGa,4BAA4B,GAAG,CAC1C,MAAgC,EAChC,UAA2C,EAC3C,MAAc;IAEd,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,yBAAyB,CACxD,MAAM,EACN,UAAU,CACX,CAAC;IACF,MAAM,mBAAmB,GAAG,iBAAiB,CAC3C,EAAE,SAAS,EAAE,SAAS,EAAE,EACxB,MAAM,CACP,CAAC;IACF,OAAO,yBAAyB,CAAC,mBAAmB,EAAE,UAAU,CAAC,CAAC;AACpE,EAAE;AAEF;;;MAGa,qBAAqB,GAAG,CACnC,EAA6B,EAC7B,EAA6B;IAE7B,MAAM,CAAC,GAAG,IAAI,CAAC;IACf,MAAM,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC;IACjD,MAAM,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC;IACjD,MAAM,CAAC,GACL,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC;YAChC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC;YAClC,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC;YAClB,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACvB,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACzD,OAAO,CAAC,GAAG,CAAC,CAAC;AACf,EAAE;AAOF;;;AAGA,MAAM,yBAAyB,GAAG,CAChC,MAAgC,EAChC,UAA2C;IAE3C,OAAO;QACL,SAAS,EAAE,UAAU,CAAC,oBAAoB,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;QACjE,SAAS,EAAE,UAAU,CAAC,oBAAoB,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;KAClE,CAAC;AACJ,CAAC,CAAC;AAEF;;;MAGa,iBAAiB,GAAG,CAC/B,EAAE,SAAS,EAAE,SAAS,EAAe,EACrC,MAAc;IAEd,SAAS,CAAC,CAAC,IAAI,MAAM,CAAC;IACtB,SAAS,CAAC,CAAC,IAAI,MAAM,CAAC;IAEtB,SAAS,CAAC,CAAC,IAAI,MAAM,CAAC;IACtB,SAAS,CAAC,CAAC,IAAI,MAAM,CAAC;IAEtB,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;AAClC,EAAE;AAEF;;;MAGa,yBAAyB,GAAG,CACvC,EAAE,SAAS,EAAE,SAAS,EAAe,EACrC,UAA2C;IAE3C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;IAC9C,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC,CAAC;IAC1D,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC,CAAC;IAC1D,OAAO,MAAM,CAAC;AAChB;;ACpHA;;;;;;;;;;;;;;;AA4DA;;;MAGsB,iBAAiB;IAGrC,YAAY,EAAE,OAAO,GAAG,EAAE,EAAoB;QAC5C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACxB;;;;;;;;;;;;;IAaS,IAAI,CAAC,EAAE,OAAO,EAAkB;QACxC,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC;KACtB;CAaF;AAaD;;;;;;MAMsB,yBAA0B,SAAQ,iBAAiB;IAGvE,YAAY,EAA8D;YAA9D,EAAE,eAAe,GAAG,EAAE,OAAwC,EAAnC,OAAO,cAAlC,mBAAoC,CAAF;QAC5C,KAAK,CAAC,OAAO,CAAC,CAAC;QAHP,oBAAe,GAAG,EAAE,CAAC;QAI7B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;KACxC;IACM,SAAS,CAAC,EACf,OAAO,EACP,GAAG,EACH,mBAAmB,GACJ;QACf,IAAI,GAAG,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE;YACjC,OAAO;gBACL,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC;oBAClB,OAAO;oBACP,GAAG;oBACH,mBAAmB;iBACpB,CAAC;gBACF,OAAO,EAAE,KAAK;aACf,CAAC;SACH;QAED,OAAO;YACL,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC;gBACrB,OAAO,EAAE,6BAA6B,CACpC,GAAG,EACH,mBAAmB,EACnB,OAAO,EACP,IAAI,CAAC,eAAe,CACrB;gBACD,GAAG;gBACH,mBAAmB;aACpB,CAAC;SACH,CAAC;KACH;CAEF;AAED;;;MAGa,IAAI,GAAG,CAAC,OAA6B;IAChD,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAC1B,CAAC,MAAM,KACL,IAAI,OAAO,CAAC;QACV,QAAQ,EAAE,MAAM,CAAC,WAAW,EAAE;QAC9B,OAAO,EAAE,CAAC,MAAM,CAAC;KAClB,CAAC,CACL,CAAC;IACF,OAAO,QAAQ,CAAC;AAClB;;ACtKA;;;;;;;;;;;;;;;AAkCA;;;;;;;MAOa,aAAc,SAAQ,yBAAyB;IAK1D,YAAY,EAA+D;YAA/D,EAAE,WAAW,GAAG,KAAK,EAAE,QAAQ,GAAG,EAAE,OAA2B,EAAtB,OAAO,cAAhD,2BAAkD,CAAF;QAC1D,KAAK,CAAC,OAAO,CAAC,CAAC;QAHP,aAAQ,GAAc,EAAE,CAAC;QAKjC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC1B;IAES,OAAO,CAAC,EAChB,OAAO,EACP,GAAG,EACH,mBAAmB,GACJ;QACf,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM;YACrB,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE,GAAG,EAAE,mBAAmB,CAAC,CAAC;SAC5D,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;IAES,mBAAmB,CAC3B,MAA0B,EAC1B,GAAoB,EACpB,UAA2C;QAE3C,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACnC,IAAI,OAAO,GAAY,IAAI,CAAC;QAE5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnC,MAAM,QAAQ,GAAG,qBAAqB,CACpC,SAAS,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,EAAE,EACrC,MAAM,CAAC,WAAW,EAAE,CAAC,MAAM,EAAE,CAC9B,CAAC;YAEF,IAAI,QAAQ,GAAG,WAAW,EAAE;gBAC1B,WAAW,GAAG,QAAQ,CAAC;gBACvB,OAAO,GAAG,SAAS,CAAC;aACrB;SACF;QAED,IACE,OAAO;YACP,4BAA4B,CAC1B,OAAO,CAAC,MAAM,EACd,UAAU,EACV,IAAI,CAAC,QAAQ,CACd,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,EAChC;YACA,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACtB;aAAM;YACL,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,EAAE,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACnD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC7B;KACF;;;ACpGH;;;;;;;;;;;;;;;AAyBA;;;MAGa,aAAc,SAAQ,iBAAiB;IAClD,YAAY,EAAgC;YAA3B,OAAO,cAAZ,EAAc,CAAF;QACtB,KAAK,CAAC,OAAO,CAAC,CAAC;KAChB;IACM,SAAS,CAAC,EACf,OAAO,EACP,GAAG,EACH,mBAAmB,GACJ;QACf,OAAO;YACL,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,mBAAmB,EAAE,CAAC;YAC7D,OAAO,EAAE,KAAK;SACf,CAAC;KACH;IAES,OAAO,CAAC,KAAqB;QACrC,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACzB;;;AC7CH;;;;;;;;;;;;;;;AA8BA;;;;;;;;MAQa,eAAgB,SAAQ,yBAAyB;IAK5D,YAAY,EAAwD;YAAxD,EAAE,gBAAgB,OAAsC,EAAjC,OAAO,cAA9B,oBAAgC,CAAF;QACxC,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;KAC1C;IAES,OAAO,CAAC,EAAE,OAAO,EAAE,GAAG,EAAkB;QAChD,MAAM,QAAQ,GAAc,EAAE,CAAC;QAE/B,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,OAAO,QAAQ,CAAC;SACjB;QACD,MAAM,MAAM,GAAG,iBAAiB,CAC9B,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM;YACjB,OAAO,KAAK,CAAC,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;SACxE,CAAC,CACH,CAAC;QAEF,IAAI,gBAAwB,CAAC;QAE7B,IAAI,IAAI,CAAC,gBAAgB,YAAY,QAAQ,EAAE;YAC7C,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;SACzE;aAAM;YACL,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;SAC1C;QACD,cAAc,CAAC,MAAM,EAAE,EAAE,gBAAgB,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,CAC3D,CAAC,KAAK,EAAE,CAAC;YACP,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;gBACvC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC;oBAC/C,QAAQ,EAAE;wBACR,GAAG,EAAE,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACjC,GAAG,EAAE,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;qBAClC;oBACD,OAAO,EAAE,EAAE;iBACZ,CAAC,CAAC;aACJ;YAED,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SACrD,CACF,CAAC;QAEF,OAAO,QAAQ,CAAC;KACjB;;;ACpFH;;;;;;;;;;;;;;;AAqCA,MAAM,8BAA8B,GAAkB;IACpD,KAAK,EAAE,YAAY;IACnB,MAAM,EAAE,KAAK;IACb,SAAS,EAAE,CAAC;CACb,CAAC;AAEF;;;;;;;;;;;MAWa,eAAgB,SAAQ,yBAAyB;IAG5D,YAAY,EAIa;YAJb,EACV,WAAW,GAAG,GAAG,EACjB,SAAS,GAAG,8BAA8B,CAAC,SAAS,OAE7B,EADpB,OAAO,cAHA,4BAIX,CADW;QAEV,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,OAAO,mCACP,8BAA8B,KACjC,SAAS,GACV,CAAC;KACH;IAES,OAAO,CAAC,EAChB,OAAO,EACP,mBAAmB,GACJ;QACf,MAAM,MAAM,GAAG,iBAAiB,CAC9B,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM;YACjB,MAAM,cAAc,GAAG,mBAAmB,CAAC,0BAA0B,CACnE,MAAM,CAAC,WAAW,EAAE,CACrB,CAAC;YACF,OAAO,KAAK,CAAC,CAAC,cAAc,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;SACpD,CAAC,CACH,CAAC;QAEF,MAAM,OAAO,GAA2B,EAAE,CAAC;QAE3C,cAAc,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,OAAO,CACrE,CAAC,KAAK,EAAE,CAAC;YACP,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;gBACtC,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;aACxC;YAED,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SACpD,CACF,CAAC;QAEF,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,KAAK,IAAI,OAAO,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;KAC3D;;;AChGH;;;;;;;;;;;;;;;AA2BA;;;;;MAKa,qBAAsB,SAAQ,iBAAiB;IAM1D,YAAY,EAAyD;YAAzD,EAAE,OAAO,EAAE,MAAM,GAAG,EAAE,OAAmC,EAA9B,OAAO,cAAlC,qBAAoC,CAAF;QAC5C,KAAK,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;QAEnB,IAAI,CAAC,YAAY,GAAG,IAAI,YAAY,iBAClC,OAAO,EAAE,IAAI,CAAC,OAAO,EACrB,MAAM,IACH,OAAO,EACV,CAAC;QAEH,IAAI,CAAC,KAAK,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;KAC7B;IACM,SAAS,CAAC,KAAqB;QACpC,IAAI,OAAO,GAAG,KAAK,CAAC;QAEpB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE;YACvC,OAAO,GAAG,IAAI,CAAC;;YAEf,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;YAElC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM;gBACrC,OAAO;oBACL,IAAI,EAAE,SAAkB;oBACxB,QAAQ,EAAE;wBACR,IAAI,EAAE,OAAgB;wBACtB,WAAW,EAAE;4BACX,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE;4BAC1B,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE;yBAC3B;qBACF;oBACD,UAAU,EAAE,EAAE,MAAM,EAAE;iBACvB,CAAC;aACH,CAAC,CAAC;YAEH,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAChC;QAED,MAAM,KAAK,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE,CAAC;QAE5C,IAAI,CAAC,OAAO,EAAE;YACZ,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,IAAI,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAEhE;iBAAM;gBACL,OAAO,GAAG,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;aAChD;SACF;QAED,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrC;QAED,OAAO,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC;KAC7C;IAEM,OAAO,CAAC,EAAE,GAAG,EAAkB;QACpC,OAAO,IAAI,CAAC,YAAY;aACrB,WAAW,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC;aAChD,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;KAC1C;IAES,gBAAgB,CAAC,EACzB,QAAQ,EAAE,EACR,WAAW,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,GACxB,EACD,UAAU,GACqC;QAC/C,IAAI,UAAU,CAAC,OAAO,EAAE;YACtB,OAAO,IAAI,OAAO,CAAC;gBACjB,OAAO,EAAE,IAAI,CAAC,YAAY;qBACvB,SAAS,CAAC,UAAU,CAAC,UAAU,EAAE,QAAQ,CAAC;qBAC1C,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;gBACxC,QAAQ,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;aAC/C,CAAC,CAAC;SACJ;aAAM;YACL,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;YAEjC,OAAO,IAAI,OAAO,CAAC;gBACjB,OAAO,EAAE,CAAC,MAAM,CAAC;gBACjB,QAAQ,EAAE,MAAM,CAAC,WAAW,EAAE;aAC/B,CAAC,CAAC;SACJ;KACF;;;ACxHH;;;;;;;;;;;;;;;AAkBA;;;MAGa,YAAY;IAYvB,YAAY,OAA6B,EAAE,QAAmB;QAC5D,IAAI,CAAC,OAAO,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC;QAEvC,MAAM,mBAAmB,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC;QACzD,MAAM,gBAAgB,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QAExE,IAAI,CAAC,QAAQ,GAAG;YACd,KAAK,EAAE,QAAQ,CAAC,MAAM;YACtB,OAAO,EAAE;gBACP,IAAI,EAAE,gBAAgB,GAAG,QAAQ,CAAC,MAAM;gBACxC,GAAG,EAAE,gBAAgB;gBACrB,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,mBAAmB,CAAC;gBACrC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,mBAAmB,CAAC;aACtC;SACF,CAAC;KACH;CACF;MAkBY,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAuCnB,MAAM,CACX,EAAE,KAAK,EAAE,QAAQ,EAAW,EAC5B,KAAmB;;QAGnB,MAAM,KAAK,GACT,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,GAAG,SAAS,CAAC;;QAG5E,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;eACb,KAAK;;;;SAIX,CAAC,CAAC;;QAGP,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAC5B,QAAQ;YACR,IAAI,EAAE;gBACJ,GAAG,EAAE,6BAA6B,GAAG,EAAE;gBACvC,UAAU,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC;aACzC;YACD,KAAK,EAAE;gBACL,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC;gBACnB,KAAK,EAAE,uBAAuB;gBAC9B,QAAQ,EAAE,MAAM;aACjB;;YAED,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,KAAK;SACtD,CAAC,CAAC;KACJ;;;ACzIH;;;;;;;;;;;;;;;AAmBA;;;;;;;AAOA;AACA,SAAS,MAAM,CAAC,KAAU,EAAE,KAAU;;;IAGpC,KAAK,IAAI,QAAQ,IAAI,KAAK,CAAC,SAAS,EAAE;QACpC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;KACvD;AACH,CAAC;AAED;;;MAGa,eAAe;IAC1B;;;;;;QAME,MAAM,CAAC,eAAe,EAAE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;KAClD;;;AC9CH;;;;;;;;;;;;;;;IA4CY;AAAZ,WAAY,qBAAqB;IAC/B,6DAAoC,CAAA;IACpC,yDAAgC,CAAA;IAChC,gDAAuB,CAAA;AACzB,CAAC,EAJW,qBAAqB,KAArB,qBAAqB,QAIhC;MAEY,4BAA4B,GAA0B,CACjE,CAA4B,EAC5B,OAAgB,EAChB,GAAoB;IAEpB,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AAChC,EAAE;AACF;;;;;;MAMa,eAAgB,SAAQ,eAAe;IAclD,YAAY,EACV,GAAG,EACH,OAAO,GAAG,EAAE,EACZ,SAAS,GAAG,IAAI,qBAAqB,CAAC,EAAE,CAAC,EACzC,QAAQ,GAAG,IAAI,eAAe,EAAE,EAChC,cAAc,GAAG,4BAA4B,GACtB;QACvB,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QAEnB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAEzB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QAErC,IAAI,GAAG,EAAE;YACP,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SAClB;KACF;IAEM,SAAS,CAAC,MAA0B,EAAE,MAAgB;QAC3D,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YACjC,OAAO;SACR;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,CAAC,MAAM,EAAE,CAAC;SACf;KACF;IAEM,UAAU,CAAC,OAA6B,EAAE,MAAgB;QAC/D,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM;YACrB,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC9B,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,CAAC,MAAM,EAAE,CAAC;SACf;KACF;IAEM,YAAY,CAAC,MAA0B,EAAE,MAAgB;QAC9D,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAE3C,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;;YAEhB,OAAO,KAAK,CAAC;SACd;QAED,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAE9B,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,CAAC,MAAM,EAAE,CAAC;SACf;QAED,OAAO,IAAI,CAAC;KACb;IAEM,aAAa,CAClB,OAA6B,EAC7B,MAAgB;QAEhB,IAAI,OAAO,GAAG,KAAK,CAAC;QAEpB,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM;YACrB,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,OAAO,CAAC;SACtD,CAAC,CAAC;QAEH,IAAI,OAAO,IAAI,CAAC,MAAM,EAAE;YACtB,IAAI,CAAC,MAAM,EAAE,CAAC;SACf;QAED,OAAO,OAAO,CAAC;KAChB;IAEM,YAAY,CAAC,MAAgB;QAClC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QAExB,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,CAAC,MAAM,EAAE,CAAC;SACf;KACF;;;;IAKM,MAAM;QACX,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAC1B,IAAI,GAAG,YAAY,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,aAAa,EAAE,EAAE;YAC1D,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CACvB,IAAI,EACJ,qBAAqB,CAAC,gBAAgB,EACtC,IAAI,CACL,CAAC;YACF,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;gBACrD,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,GAAG;gBACH,mBAAmB,EAAE,IAAI,CAAC,aAAa,EAAE;aAC1C,CAAC,CAAC;;YAGH,IAAI,OAAO,IAAI,OAAO,IAAI,SAAS,EAAE;;gBAEnC,IAAI,CAAC,KAAK,EAAE,CAAC;;gBAGb,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;gBAEzB,IAAI,CAAC,cAAc,EAAE,CAAC;aACvB;YACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CACvB,IAAI,EACJ,qBAAqB,CAAC,cAAc,EACpC,IAAI,CACL,CAAC;SACH;KACF;IAEM,KAAK;QACV,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,WAAW,CAC3C,MAAM,EACN,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CACvB,CAAC;QACF,IAAI,CAAC,MAAM,EAAE,CAAC;KACf;IAEM,QAAQ;QACb,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACpD,IAAI,CAAC,KAAK,EAAE,CAAC;KACd;IAES,KAAK;QACb,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QACtD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;QACrD,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;KACpB;IAES,cAAc;;QAEtB,MAAM,KAAK,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5D,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,EAAqB,CAAC;QAE7C,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO;YAC5B,IAAI,OAAO,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;gBAChC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aACrC;iBAAM;gBACL,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gBAEtD,IAAI,IAAI,CAAC,cAAc,EAAE;oBACvB,OAAO,CAAC,MAAM,CAAC,WAAW,CACxB,OAAO;;oBAEP,CAAC,KAAgC;wBAC/B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CACvB,IAAI,EACJ,qBAAqB,CAAC,aAAa,EACnC,OAAO,CACR,CAAC;wBACF,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;qBAC1C,CACF,CAAC;iBACH;aACF;YAED,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SAC5B,CAAC,CAAC;KACJ;;;;;"}